C51 COMPILER V9.59.0.0   BLUETOOTH                                                         06/04/2022 21:36:13 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BLUETOOTH
OBJECT MODULE PLACED IN .\Objects\BLUETOOTH.obj
COMPILER INVOKED BY: D:\KEIL\C51\BIN\C51.EXE BLUETOOTH.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\BL
                    -UETOOTH.lst) TABS(2) OBJECT(.\Objects\BLUETOOTH.obj)

line level    source

   1          #include<reg52.h>
   2          #define uint  unsigned int
   3          #define uchar unsigned char
   4          unsigned char DataGet;
   5          unsigned int flag1=0;
   6          unsigned int flag2=0;
   7          void SendData(unsigned char c);
   8          void ReceiveData();
   9          unsigned int Tstrcmp(unsigned char *str1, unsigned char *str2 );
  10          
  11          /*初始化子程序*/
  12          void Init()
  13          {
  14   1        //定时器0初始化
  15   1        TMOD=0x20;//M1:M0=10 定时器0工作方式2, 可重置8位
  16   1        
  17   1        IT1=0;//低电平
  18   1        ET1=0;//中断允许
  19   1        TR1=1;//开启定时器计数
  20   1        
  21   1        TH1=0xfd;
  22   1        TL1=0xfd;//设置定时器初值
  23   1      //  TH1=0xFF;
  24   1      //  TL1=0xE8;
  25   1        PCON=0x00;//SCON=0
  26   1        
  27   1        //串口初始化
  28   1        SM0=0;
  29   1        SM1=1;//串口工作方式1 8位UART
  30   1        REN=1;//使能串行接收
  31   1        ES=1;//串口中断允许
  32   1        EA=1;//开启总中断允许位
  33   1        
  34   1      //  SCON = 0x50;    //8位数据,可变波特率
  35   1      //  AUXR &= 0xBF;   //定时器1时钟为Fosc/12,即12T
  36   1      //  AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
  37   1      //  TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
  38   1      //  TL1 = 0xE8;   //设定定时初值
  39   1      //  TH1 = 0xFF;   //设定定时初值
  40   1      //  ET1 = 0;    //禁止定时器1中断
  41   1      //  TR1 = 1;    //启动定时器1
  42   1      
  43   1      }
  44          
  45          /*数据发送子函数*/
  46          void SendData(int humidity)
  47          { int i=0;
*** WARNING C235 IN LINE 47 OF BLUETOOTH.c: parameter 1: different types
  48   1        unsigned char gewei,shiwei,array1[]={"HUMIDITY:  "};
  49   1        gewei=humidity%10+'0';
  50   1        shiwei=humidity/10+'0';
  51   1        array1[9]=shiwei;
  52   1        array1[10]=gewei;
  53   1      
C51 COMPILER V9.59.0.0   BLUETOOTH                                                         06/04/2022 21:36:13 PAGE 2   

  54   1        while(array1[i] != '\0')
  55   1        { 
  56   2          SBUF=array1[i];
  57   2          while(!TI);//若没有发送完数据 等待
  58   2          TI=0;//若发送完 标志位清0
  59   2          i++;
  60   2        }
  61   1      
  62   1      }
  63          
  64          /*数据接收子函数*/
  65          
  66          void ReceiveData()
  67          { 
  68   1        
  69   1        
  70   1        //若发送完 标志位清0
  71   1      }
  72          /*串口收发中断服务程序
  73          触发串口中断的是发送中断
  74          或者是接收中断*/
  75          
  76          
  77          //单片机字符串比较
  78          unsigned int Tstrcmp(unsigned char *str1, unsigned char *str2 )
  79          {
  80   1        
  81   1        while(1)
  82   1        {
  83   2          
  84   2          if(*str1!=*str2)
  85   2            return 1;//不相等
  86   2          if(*str1=='\0')
  87   2            break;//对比完成了.
  88   2          str1++;
  89   2          str2++;
  90   2        }
  91   1        return 0;
  92   1        
  93   1      }
  94          /*主函数*/
  95          void main()
  96          {int humidity;
  97   1        humidity=65;
  98   1        P1=0x55;
  99   1        Init();
 100   1        SendData(humidity);
 101   1        ReceiveData();
 102   1        while(1)
 103   1          {
 104   2            
 105   2          }
 106   1      }
 107          void SeriesInterrupt() interrupt 4
 108          { 
 109   1        /*if(TI)//发送完毕 发送中断位TI置1
 110   1        {
 111   1          TI=0;
 112   1        }*/
 113   1        EA=0;
 114   1        if(RI)//接收完毕 接收中断位RI置1
 115   1        { DataGet = SBUF;  //??????48???????????з??????????????ASCII??
C51 COMPILER V9.59.0.0   BLUETOOTH                                                         06/04/2022 21:36:13 PAGE 3   

 116   2        
 117   2          RI=0;
 118   2          //DataGet=SBUF;//取出接收的数据
 119   2          
 120   2      //    if(DataGet=="ON")
 121   2      //    {
 122   2      //      //SendData(DataGet);//将接收的数据发送出去
 123   2      //      P1=0x00;
 124   2      //    }
 125   2      //    else
 126   2      //    {
 127   2      //      P1=0xFF;
 128   2      //      
 129   2      //    }
 130   2          SendData(DataGet);//将接收的数据发送出去
 131   2      //    flag1=Tstrcmp(DataGet, "Y");
 132   2      //    flag2=Tstrcmp(DataGet, "N");
 133   2          if(DataGet=='Y')
 134   2            P1=0x00;//开灯
 135   2          else if(DataGet=='N')
 136   2            P1=0xFF;//关灯
 137   2          else
 138   2            P1=0x55;//交替
 139   2        }
 140   1        EA=1;
 141   1      }
 142          
 143          
 144          
 145          //--------------------------------------------------------------------------------------------------------
             -------------------------------
 146          //#include<reg52.h>
 147          //#include<intrins.h>
 148          
 149          //#define uchar unsigned char
 150          //#define uint  unsigned int
 151          
 152          //uchar uart_receive_buffer[30];  //?????????????
 153          //uchar uart_receive_number=0;    //????????????
 154          
 155          
 156          ///********************************************************************
 157          //* ???? : Delay_1ms()
 158          //* ???? : ??????????????? 1ms
 159          //* x * ???? : x (????????????)
 160          //* ??? : ??
 161          //***********************************************************************/
 162          //void Delay_1ms(uint i)//1ms???
 163          //{
 164          //  uchar x,j;
 165          //  
 166          //  for(j=0;j<i;j++)
 167          //    for(x=0;x<=148;x++);
 168          //}
 169          
 170          ///********************************************************************
 171          //* ???? : Com_Int()
 172          //* ???? : ?????ж??????
 173          //* ???? : ?? * ??? : ??
 174          //***********************************************************************/
 175          //void Com_Int(void) interrupt 4
 176          //{
C51 COMPILER V9.59.0.0   BLUETOOTH                                                         06/04/2022 21:36:13 PAGE 4   

 177          //  static uchar i = 7;  //???????????????????????????????? i ????????????
 178          //  Delay_1ms(10);
 179          //  EA = 0;
 180          //  if(RI == 1){  //????????????????????RI????λ
 181          //    RI = 0;
 182          //    uart_receive_buffer[uart_receive_number] = SBUF;  //??????48???????????з??????????????ASCII??
 183          //    uart_receive_number++;
 184          //  }
 185          //  EA = 1;
 186          //}
 187          
 188          ///********************************************************************
 189          //* ???? : Com_Init()
 190          //* ???? : ??????????????11.0592,??????9600???????????ж?
 191          //* ???? : ??
 192          //* ??? : ??
 193          //***********************************************************************/
 194          //void Com_Init(void) {
 195          //  TMOD = 0x20;
 196          //  PCON = 0x00;
 197          //  SCON = 0x50;
 198          //  TH1 = 0xFd;  //???ò????? 9600
 199          //  TL1 = 0xFd;
 200          //  TR1 = 1;  //?????????1
 201          //  ES = 1;  //???????ж?
 202          //  EA = 1;  //?????ж?
 203          //}
 204          
 205          ///********************************************************************
 206          //* ???? : Main()
 207          //* ???? : ??????
 208          //* ???? : ??
 209          //* ??? : ??
 210          //***********************************************************************/
 211          //void Main()
 212          //{
 213          //  uchar uart_receive_number_old=0;
 214          //  
 215          //  Com_Init();
 216          //  P1=0x55;
 217          //  
 218          //  while(1){
 219          //    
 220          //    if(uart_receive_number_old!=uart_receive_number){
 221          //      uart_receive_number_old=uart_receive_number;
 222          //      P1=0x00;//开灯
 223          
 224          //    }
 225          //    
 226          //    //????????????????????1??????????????????????????ж????
 227          //    //???д????????????????????????????????????????
 228          //    Delay_1ms(30);
 229          //    
 230          //    //?????????????????????λ??????????????????
 231          //    if(uart_receive_number_old==uart_receive_number){
 232          //      P1=0xFF;//关灯
 233          //      if(uart_receive_number)
 234          //        break;
 235          //    }
 236          //  }
 237          //  
 238          //  if(uart_receive_number){
C51 COMPILER V9.59.0.0   BLUETOOTH                                                         06/04/2022 21:36:13 PAGE 5   

 239          //    //?????????????????Щ??????????
 240          //  }
 241          //  
 242          //  while(1);
 243          //}
 244          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    296    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
