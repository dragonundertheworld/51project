;主机初始化串口
S_INIT: 
TEMP EQU R1
MOV SCON, #0D0H
MOV TMOD, #20H
MOV TH1,#0FDH
MOV TL1,#0FDH
SETB TR1

;主程序，在数码管上显示数据
START:
SETB P1.0
CLR P1.1
MOV P2,#11111110B;??
SETB P1.1
CLR P1.0
MOV P2,29H
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#11111101B;??
SETB P1.1
CLR P1.0
MOV P2,28H
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#11111011B;??
SETB P1.1
CLR P1.0
MOV P2,26H
SETB P2.7
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#11110111B;??
SETB P1.1
CLR P1.0
MOV P2,27H
LCALL DELAY

SETB P1.0
CLR P1.1
MOV P2,#11101111B;??
SETB P1.1
CLR P1.0
MOV P2,32H
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#11011111B;??
SETB P1.1
CLR P1.0
MOV P2,30H
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#10111111B;??
SETB P1.1
CLR P1.0
MOV P2,33H
SETB P2.7
LCALL DELAY
SETB P1.0
CLR P1.1
MOV P2,#01111111B;??
SETB P1.1
CLR P1.0
MOV P2,31H
LCALL DELAY
JB RI,COMMU
LJMP START

;过渡程序->跳转到发送地址程序段
TRANS:
LJMP SEND_ADDR1

;主从之间开始传输
COMMU:
CLR RI

;主机发送从机1地址：准备和从机1握手
SEND_ADDR1:
SETB TB8
;??IB8,???????????
MOV A,#1
MOV SBUF,A ;??????
JNB TI, $
;????????????
CLR TI

;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK1:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #1, T
JMP RECEIVE1
T:LJMP TRANS1
;?????????

;主机接收数据并进行奇偶校验，该数据是温度数据的整数部分
RECEIVE1:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2;?c=0,?????,??????
CLR ACC.7
;??A??????????
MOV 28H,A 

;主机发送从机1地址：准备和从机1第二次握手
SEND_ADDR2:
SETB TB8
;??IB8,???????????
MOV A,#1
MOV SBUF, A ;??????
JNB TI, $
;????????????
CLR TI

;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK2:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #1, TRANS1
;?????????

;主机接收数据并进行奇偶校验，该数据是温度数据的小数部分
RECEIVE2:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2;?c=0,?????,??????
CLR ACC.7
;??A??????????
MOV 27H,A 

;主机发送从机1地址：准备和从机1第三次握手
SEND_ADDR3:
SETB TB8
;??IB8,???????????
MOV A,#1
MOV SBUF, A ;??????
JNB TI, $
;????????????
CLR TI

;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK3:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #1, TRANS1
;?????????

;主机接收数据并进行奇偶校验，该数据是温度数据的符号部分
RECEIVE3:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2;?c=0,?????,??????
CLR ACC.7
;??A??????????
MOV 29H,A 
AJMP SEND_ADDR1_0
;LJMP START
;?SM2???

;由于JNC，CJNE等语句跳转范围有限，需要过渡程序
TRANS1:LJMP FAIL
TRANS2:LJMP ERROR

;主机发送从机2地址：准备和从机2第一次握手
SEND_ADDR1_0:
SETB TB8
;??IB8,???????????
MOV A,#0
MOV SBUF,A ;??????
JNB TI, $
;????????????
CLR TI


;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK1_0:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #0, T
JMP RECEIVE1_0
LJMP TRANS1_0
;?????????

;主机接收数据并进行奇偶校验，该数据是温度数据的小数部分
RECEIVE1_0:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2_0;?c=0,?????,??????
CLR ACC.7
;??A??????????
MOV 30H,A 

;主机发送从机2地址：准备和从机2第二次握手
SEND_ADDR2_0:
SETB TB8
;??IB8,???????????
MOV A,#0
MOV SBUF, A ;??????
JNB TI, $
;????????????
CLR TI

;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK2_0:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #0, TRANS1_0
;?????????

;主机接收数据并进行奇偶校验，该数据是温度数据的整数部分
RECEIVE2_0:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2_0;?c=0,?????,??????
CLR ACC.7
;??A??????????
MOV 31H,A 

;主机发送从机2地址：准备和从机2第三次握手
SEND_ADDR3_0:
SETB TB8
;??IB8,???????????
MOV A,#0
MOV SBUF, A ;??????
JNB TI, $
;????????????
CLR TI

;检测从机的应答信号：若应答不正确则返回上一步；正确则继续
CHECK3_0:
JNB RI, $;
CLR RI
MOV A, SBUF
CJNE A, #0, TRANS1_0

;主机接收数据并进行奇偶校验，该数据是温度数据的符号部分
RECEIVE3_0:
JNB RI,$
CLR RI
MOV A, SBUF
MOV C,P;????????C
JNC TRANS2_0;?c=0,?????,??????
CLR ACC.7
MOV 32H,A

;调用SEP12
LCALL SEP1
LCALL SEP2

LJMP START
;?SM2???

DELAY:
MOV R0,#100
LOOP:
MOV R1,#10
DJNZ R1,$
DJNZ R0,LOOP
RET

;由于JNC，CJNE等语句跳转范围有限，需要过渡程序
TRANS1_0:LJMP FAIL
TRANS2_0:LJMP ERROR

;采用查表方式进行数码管显示
SEP1:
MOV A,28H
MOV B,#0AH
DIV AB
MOV DPTR,#1000H
MOVC A,@A+DPTR
MOV 28H,A
MOV A,B
MOVC A,@A+DPTR
MOV 26H,A
RET

SEP2:
MOV A,30H
MOV B,#0AH
DIV AB
MOV DPTR,#1000H
MOVC A,@A+DPTR
MOV 30H,A
MOV A,B
MOVC A,@A+DPTR
MOV 33H,A
RET

;出错时跳转进下面两个函数之一
FAIL:
MOV P2,#00001111B
AJMP FAIL
ERROR: 
MOV P1,#11110000B
AJMP $
CLR SM2

;表格
ORG 1000H
TAB:
DB 03FH,06H,5BH,4FH,66H,6DH,7DH,07H,07FH,6FH
END
