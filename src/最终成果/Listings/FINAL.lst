C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE FINAL
OBJECT MODULE PLACED IN .\Objects\FINAL.obj
COMPILER INVOKED BY: D:\KEIL\C51\BIN\C51.EXE FINAL.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\FINAL.
                    -lst) TABS(2) OBJECT(.\Objects\FINAL.obj)

line level    source

   1          sbit E = P1^3
*** ERROR C202 IN LINE 1 OF FINAL.c: 'P1': undefined identifier
   2          sbit RW = P1^2
*** ERROR C141 IN LINE 2 OF FINAL.c: syntax error near 'sbit', expected ';'
*** ERROR C202 IN LINE 2 OF FINAL.c: 'P1': undefined identifier
   3          sbit RS = P1^1
*** ERROR C141 IN LINE 3 OF FINAL.c: syntax error near 'sbit', expected ';'
*** ERROR C202 IN LINE 3 OF FINAL.c: 'P1': undefined identifier
   4          sbit DB = P1^0
*** ERROR C141 IN LINE 4 OF FINAL.c: syntax error near 'sbit', expected ';'
*** ERROR C202 IN LINE 4 OF FINAL.c: 'P1': undefined identifier
   5          
   6          /*******************************************************************************
   7          * 函 数 名         : LcdWriteCom
   8          * 函数功能       : 向LCD写入一个字节的命令
   9          * 输    入         : u8com
  10          * 输    出         : 无
  11          *******************************************************************************/
  12          void lcd_wri_com(unsigned char com)   //写入命令
*** ERROR C141 IN LINE 12 OF FINAL.c: syntax error near 'void', expected ';'
  13          {
  14   1        E = 0;   //使能清零
*** ERROR C202 IN LINE 14 OF FINAL.c: 'E': undefined identifier
  15   1        RS = 0;  //选择写入命令
*** ERROR C202 IN LINE 15 OF FINAL.c: 'RS': undefined identifier
  16   1        RW = 0;  //选择写入
*** ERROR C202 IN LINE 16 OF FINAL.c: 'RW': undefined identifier
  17   1       
  18   1        DB = com;
*** ERROR C202 IN LINE 18 OF FINAL.c: 'DB': undefined identifier
  19   1        delay_ms(1);
  20   1       
  21   1        E = 1;   //写入时序
  22   1        delay_ms(5);
  23   1        E = 0;
  24   1      }
  25           
  26          /*******************************************************************************
  27          * 函 数 名         : LcdWriteData
  28          * 函数功能       : 向LCD写入一个字节的数据
  29          * 输    入         : u8dat
  30          * 输    出         : 无
  31          *******************************************************************************/
  32           
  33          void lcd_wri_data(unsigned char dat)//写入数据
  34          {
  35   1        E = 0;    //使能清零
  36   1        RS = 1;   //选择写入数据
  37   1        RW = 0;   //选择写入
  38   1        DB = dat;
  39   1        delay_ms(1);
  40   1        E = 1;    //写入时序
  41   1        delay_ms(5);
  42   1        E = 0;
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 2   

  43   1      }
  44          /*******************************************************************************
  45          * 函 数 名         : WriString
  46          * 函数功能       : 刷新屏幕显示
  47          * 输    入         : hang，add，*p
  48          * 输    出         : 无
  49          *******************************************************************************/
  50          void wri_string(unsigned char y,unsigned char x,unsigned char *p)
  51          {
  52   1        if(y==1)//如果选择第一行
  53   1          lcd_wri_com(0x80+x);//选中地址
  54   1        else
  55   1          lcd_wri_com(0xc0+x);//选中地址
  56   1          while(*p)
  57   1          {
  58   2            lcd_wri_data(*p);//写入数据
  59   2            p++;
  60   2          }
  61   1      }
  62          /*******************************************************************************
  63          * 函 数 名         : lcd_write_char
  64          * 函数功能       :
  65          * 输    入         :
  66          * 输    出         : 无
  67          *******************************************************************************/
  68          void lcd_write_char(unsigned char y, unsigned char x, unsigned char dat) //列x=0~15,行y=0,1
  69          {
  70   1        unsigned char temp_l, temp_h;
  71   1        if(y==1)//如果选择第一行
  72   1          lcd_wri_com(0x80+x);//选中地址
  73   1        else
  74   1          lcd_wri_com(0xc0+x);//选中地址
  75   1        temp_l = dat % 10;
  76   1          temp_h = dat / 10;
  77   1          lcd_wri_data(temp_h + 0x30);          //convert to ascii
  78   1          lcd_wri_data(temp_l + 0x30);
  79   1      }
  80          /*********************光标控制***********************/
  81          void lcd1602_guanbiao(unsigned char y, unsigned char x,unsigned char on_off)
  82          {
  83   1        if(on_off == 1)   //开光标
  84   1        {
  85   2          if(y==1)//如果选择第一行
  86   2          lcd_wri_com(0x80+x);
  87   2            else
  88   2          lcd_wri_com(0xc0+x);//将光标移动到秒个位
  89   2          lcd_wri_com(0x0f);//显示光标并且闪烁
  90   2        }
  91   1        else
  92   1        {
  93   2              if(y==1)//如果选择第一行
  94   2          lcd_wri_com(0x80+x);
  95   2            else
  96   2          lcd_wri_com(0xc0+x);//将光标移动到秒个位
  97   2          lcd_wri_com(0x0c);   //关光标
  98   2        }
  99   1      }
 100           
 101          /*******************************************************************************
 102          * 函 数 名       : LcdInit()
 103          * 函数功能     : 初始化LCD屏
 104          * 输    入       : 无
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 3   

 105          * 输    出       : 无
 106          *******************************************************************************/
 107          void lcd_init(void)             //LCD初始化子程序
 108          {
 109   1        lcd_wri_com(0x38);//置功能8位双行
 110   1        lcd_wri_com(0x0c);//显示开关光标
 111   1        lcd_wri_com(0x06);//字符进入模式屏幕不动字符后移
 112   1        delay_ms(5);//延时5ms
 113   1        lcd_wri_com(0x01);  //清屏
 114   1        wri_string(2,0,times);//初始化显示
 115   1        wri_string(2,6,date);
 116   1        wri_string(1,0,"H:   %RH T:   C ");//初始化显示
 117   1      }
 118          void DHT11_delay_us(unsigned char n)
 119          {
 120   1          while(--n);
 121   1      }
 122           
 123          void DHT11_delay_ms(unsigned int z)
 124          {
 125   1         unsigned int i,j;
 126   1         for(i=z;i>0;i--)
 127   1            for(j=110;j>0;j--);
 128   1      }
 129           
 130          void DHT11_start()
 131          {
 132   1         Data=1;
 133   1         DHT11_delay_us(2);
 134   1         Data=0;
 135   1         DHT11_delay_ms(30);   //延时18ms以上
 136   1         Data=1;
 137   1         DHT11_delay_us(30);
 138   1      }
 139           
 140          unsigned char DHT11_rec_byte()      //接收一个字节
 141          {
 142   1         unsigned char i,dat=0;
 143   1        for(i=0;i<8;i++)    //从高到低依次接收8位数据
 144   1         {
 145   2            while(!Data);   等待50us低电平过去
 146   2            DHT11_delay_us(8);     //延时60us，如果还为高则数据为1，否则为0
 147   2            dat<<=1;           //移位使正确接收8位数据，数据为0时直接移位
 148   2            if(Data==1)    //数据为1时，使dat加1来接收数据1
 149   2               dat+=1;
 150   2            while(Data);  //等待数据线拉低
 151   2          }
 152   1          return dat;
 153   1      }
 154           
 155          void DHT11_receive()      //接收40位的数据
 156          {
 157   1          unsigned char R_H,R_L,T_H,T_L,RH,RL,TH,TL,revise;
 158   1          DHT11_start();
 159   1          if(Data==0)
 160   1          {
 161   2              while(Data==0);   //等待拉高
 162   2              DHT11_delay_us(40);  //拉高后延时80us
 163   2              R_H=DHT11_rec_byte();    //接收湿度高八位
 164   2              R_L=DHT11_rec_byte();    //接收湿度低八位
 165   2              T_H=DHT11_rec_byte();    //接收温度高八位
 166   2              T_L=DHT11_rec_byte();    //接收温度低八位
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 4   

 167   2              revise=DHT11_rec_byte(); //接收校正位
 168   2       
 169   2              DHT11_delay_us(25);    //结束
 170   2       
 171   2              if((R_H+R_L+T_H+T_L)==revise)      //校正
 172   2              {
 173   3                  RH=R_H;
 174   3                  RL=R_L;
 175   3                  TH=T_H;
 176   3                  TL=T_L;
 177   3              }
 178   2              humi_value = RH;
 179   2              temp_value = TH;
 180   2          }
 181   1      }
 182           
 183           
 184          void AlarmJudge(void)
 185          {
 186   1      //  if(temp_value>AlarmTH)// 温度是否过高
 187   1      //  {
 188   1      //    LedTH_P=0;
 189   1      //    LedTL_P=1;
 190   1      //  }
 191   1      //  else if(temp_value<AlarmTL)// 温度是否过低
 192   1      //  {
 193   1      //    LedTL_P=0;
 194   1      //    LedTH_P=1;
 195   1      //  }
 196   1      //  else// 温度正常
 197   1      //  {
 198   1      //    LedTH_P=1;
 199   1      //    LedTL_P=1;
 200   1      //  }
 201   1       
 202   1        if(humi_value>AlarmHH)// 湿度是否过高
 203   1        {
 204   2          LedHH_P=0;
 205   2            LedHL_P=1;
 206   2        }
 207   1        else if(humi_value<AlarmHL) // 湿度是否过低
 208   1        {
 209   2          LedHL_P=0;
 210   2          LedHH_P=1;
 211   2        }
 212   1        else  // 湿度正常
 213   1        {
 214   2          LedHH_P=1;
 215   2          LedHL_P=1;
 216   2        }
 217   1       
 218   1      //  if((LedHH_P==0)||(LedHL_P==0)||(LedTH_P==0)||(LedTL_P==0))  // 蜂鸣器判断，只要至少1个报警
             -灯亮，蜂鸣器就报警
 219   1      //  {
 220   1      //    for(i=0;i<3;i++)
 221   1      //    {
 222   1      //      beep=0;
 223   1      //      delay_ms(20);
 224   1      //      beep=1;
 225   1      //      delay_ms(20);
 226   1      //    }
 227   1      //  }
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 5   

 228   1      }
 229           
 230           
 231           
 232           
 233           
 234          void key_handle(void)
 235          {
 236   1        
 237   1        
 238   1      }
 239          void key_scan(void)
 240          {
 241   1        static unsigned char key_in_flag = 0;//按键按下标志
 242   1        unsigned char key_l;//存储扫描到行列值。
 243   1      //  key_value = 20;//按键值清除
 244   1      //  if((P3 | 0xf0) != 0xf0)//按键按下
 245   1      //  {
 246   1      //    delay_ms(1);//按键消抖动
 247   1      //    if(((P3 | 0xf0) != 0xf0) && (key_in_flag == 1))
 248   1      //    {
 249   1      //      key_in_flag = 0;//松手检测防止一直触发
 250   1      //      P3 = 0xf0;
 251   1      //            //delay_ms(1);//按键消抖动
 252   1      //      key_l = P3;//扫描得到按键值
 253   1      //      switch(key_l)
 254   1      //      {
 255   1      //        //获取按键值
 256   1      //        case 0xf1:
 257   1      //        {
 258   1      //          key_value = 1;
 259   1      //        }
 260   1      //        break;
 261   1      //        case 0xf2:
 262   1      //        {
 263   1      //          key_value = 2;
 264   1      //        }
 265   1      //        break;
 266   1      //        case 0xf4:
 267   1      //        {
 268   1      //          key_value = 3;
 269   1      //        }
 270   1      //        break;
 271   1      //        //case 0x70:
 272   1      //        //break;
 273   1      //      }
 274   1      //    }
 275   1      //  }
 276   1      //  else
 277   1      //  {
 278   1      //    key_in_flag = 1;//(按键松开标志)
 279   1       
 280   1       
 281   1       
 282   1      //  }
 283   1        if(KEY1 == 1)
 284   1        {
 285   2          delay_ms(5);
 286   2          if(KEY1 == 1)
 287   2          {
 288   3              mode = 0;
 289   3              wri_string(2,12,"Auto");//初始化显示
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 6   

 290   3              while(KEY1);
 291   3            
 292   3          }
 293   2        }
 294   1           if(KEY2 == 1)
 295   1          {
 296   2            delay_ms(5);
 297   2             if(KEY2 == 1)
 298   2            {
 299   3                mode = 1;
 300   3                wri_string(2,12,"Manu");//初始化显示
 301   3                while(KEY2);
 302   3            }
 303   2            
 304   2          }
 305   1           if(KEY3 == 1)
 306   1          {
 307   2              delay_ms(5);
 308   2               if(KEY3 == 1)
 309   2              {
 310   3                motor_direc = 0;//正转
 311   3                if(motor_mode == 0)
 312   3                {
 313   4                  motor_mode = 1;
 314   4                }
 315   3                else
 316   3                {
 317   4                  motor_mode = 0;
 318   4                }
 319   3                while(KEY3);
 320   3            }
 321   2            
 322   2          }
 323   1          if(KEY4 == 1)
 324   1          {
 325   2            delay_ms(5);
 326   2            if(KEY4 == 1)
 327   2            {
 328   3              motor_direc = 1;
 329   3              if(motor_mode == 0)
 330   3                {
 331   4                  motor_mode = 1;
 332   4                }
 333   3                else
 334   3                {
 335   4                  motor_mode = 0;
 336   4                }
 337   3                while(!KEY4);
 338   3            }
 339   2            
 340   2          }
 341   1        
 342   1      }
 343           
 344           
 345          /******************************************************
 346           ** 函数名：key_service
 347           ** 描述  ：按键服务函数
 348           ** 输入  ：无
 349           ** 输出  ：无
 350           ** 调用  ：主程序
 351          ******************************************************/
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 7   

 352          void key_service(void)
 353          {
 354   1          switch (now_window)
 355   1          {
 356   2                 case  normal_mode:
 357   2                 {
 358   3                    if (key_value == 1)
 359   3                    {
 360   4                          now_window = set_mode;
 361   4                          curr_menu = 0;
 362   4                          wri_string(1,0,"T:  -           ");//初始化显示
 363   4                          wri_string(2,0,"H:  -           ");//初始化显示
 364   4                          lcd_write_char(1,2,AlarmTL);
 365   4                          lcd_write_char(1,6,AlarmTH);
 366   4                          lcd_write_char(2,2,AlarmHL);
 367   4                          lcd_write_char(2,6,AlarmHH);
 368   4                          lcd1602_guanbiao(1,3,1);
 369   4                    }
 370   3                 }
 371   2                 break;
 372   2                 case  set_mode:
 373   2                 {
 374   3                          if (key_value == 1)
 375   3                          {
 376   4                                  ++curr_menu;
 377   4                                  if (curr_menu==1)
 378   4                                  {
 379   5                                      lcd1602_guanbiao(1,7,1);
 380   5                                  }
 381   4                                  else if(curr_menu==2)
 382   4                                  {
 383   5                                      lcd1602_guanbiao(2,3,1);
 384   5                                  }
 385   4                                  else if(curr_menu==3)
 386   4                                  {
 387   5                                      lcd1602_guanbiao(2,7,1);
 388   5                                  }
 389   4                                  if(curr_menu>3)
 390   4                                  {
 391   5                                      curr_menu = 0;
 392   5                                      lcd1602_guanbiao(2,7,0);
 393   5                                      now_window = normal_mode;
 394   5                                      wri_string(2,0,times);//初始化显示
 395   5                                      wri_string(2,6,date);
 396   5                                      wri_string(2,0,"                    ");//初始化显示
 397   5                                      wri_string(1,0,"H:   %RH T:   C ");//初始化显示
 398   5                                      lcd_write_char(1,2,humi_value);
 399   5                                      lcd_write_char(1,11,temp_value);
 400   5      //                                lcd_wri_com(0xcd);
 401   5      //                                lcd_wri_data(0xdf);
 402   5                                  }
 403   4                          }
 404   3                          if (key_value == 2)
 405   3                          {
 406   4                                  if(curr_menu==0)
 407   4                                  {
 408   5                                       if(++AlarmTL>99)
 409   5                                       {
 410   6                                           AlarmTL = 0;
 411   6                                       }
 412   5                                       lcd_write_char(1,2,AlarmTL);
 413   5                                       lcd1602_guanbiao(1,3,1);
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 8   

 414   5                                  }
 415   4                                  else if (curr_menu==1)
 416   4                                  {
 417   5                                       if(++AlarmTH>99)
 418   5                                       {
 419   6                                           AlarmTH = 0;
 420   6                                       }
 421   5                                       lcd_write_char(1,6,AlarmTH);
 422   5                                       lcd1602_guanbiao(1,7,1);
 423   5                                  }
 424   4                                  else if(curr_menu==2)
 425   4                                  {
 426   5                                      if(++AlarmHL>99)
 427   5                                       {
 428   6                                           AlarmHL = 0;
 429   6                                       }
 430   5                                       lcd_write_char(2,2,AlarmHL);
 431   5                                       lcd1602_guanbiao(2,3,1);
 432   5                                  }
 433   4                                  else if(curr_menu==3)
 434   4                                  {
 435   5                                       if(++AlarmHH>99)
 436   5                                       {
 437   6                                           AlarmHH = 0;
 438   6                                       }
 439   5                                       lcd_write_char(2,6,AlarmHH);
 440   5                                       lcd1602_guanbiao(2,7,1);
 441   5                                  }
 442   4                          }
 443   3                          if (key_value == 3)
 444   3                          {
 445   4                                  if(curr_menu==0)
 446   4                                  {
 447   5                                       if(--AlarmTL<0)
 448   5                                       {
 449   6                                           AlarmTL = 99;
 450   6                                       }
 451   5                                       lcd_write_char(1,2,AlarmTL);
 452   5                                        lcd1602_guanbiao(1,3,1);
 453   5                                  }
 454   4                                  else if (curr_menu==1)
 455   4                                  {
 456   5                                       if(--AlarmTH<0)
 457   5                                       {
 458   6                                           AlarmTH = 99;
 459   6                                       }
 460   5                                       lcd_write_char(1,6,AlarmTH);
 461   5                                       lcd1602_guanbiao(1,7,1);
 462   5                                  }
 463   4                                  else if(curr_menu==2)
 464   4                                  {
 465   5                                      if(--AlarmHL<0)
 466   5                                       {
 467   6                                           AlarmHL = 99;
 468   6                                       }
 469   5                                        lcd_write_char(2,2,AlarmHL);
 470   5                                         lcd1602_guanbiao(2,3,1);
 471   5                                  }
 472   4                                  else if(curr_menu==3)
 473   4                                  {
 474   5                                      if(--AlarmHH<0)
 475   5                                       {
C51 COMPILER V9.59.0.0   FINAL                                                             05/27/2022 21:32:25 PAGE 9   

 476   6                                           AlarmHH = 99;
 477   6       
 478   6                                       }
 479   5                                       lcd_write_char(2,6,AlarmHH);
 480   5                                        lcd1602_guanbiao(2,7,1);
 481   5                                  }
 482   4                          }
 483   3                 }
 484   2                 break;
 485   2          }
 486   1      }
 487          /******************************************************
 488           ** 函数名：alm
 489           ** 描述  ：定时闪烁函数
 490           ** 输入  : 无
 491           ** 输出  ：无
 492           ** 调用  ：中断调用
 493           ******************************************************/
 494           
 495          void main(void)
 496          {
 497   1       
 498   1         init_all_hardware();//初始化硬件，IO和定时器
 499   1         while(1)
 500   1         {
 501   2       
 502   2           
 503   2           key_scan();//按键扫描
 504   2           key_handle();
 505   2          
 506   2           time_service();//时间处理函数
 507   2           Get_Light();
 508   2         }
 509   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  12 ERROR(S)
