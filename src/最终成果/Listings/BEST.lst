C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BEST
OBJECT MODULE PLACED IN .\Objects\BEST.obj
COMPILER INVOKED BY: D:\KEIL\C51\BIN\C51.EXE BEST.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\BEST.ls
                    -t) TABS(2) OBJECT(.\Objects\BEST.obj)

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #include<absacc.h>    //头文件
   4          
   5          
   6          #define uc unsigned char
   7          #define ui unsigned int 
   8            //引脚定义
   9          #define LCD P2
  10          
  11          sbit RS = P0^1;
  12          sbit RW = P0^2;
  13          sbit E = P0^3;
  14          
  15          
  16          sbit in_forward   = P1^2;
  17          sbit in_backward  = P1^1;//手动前进后退按键 
  18          sbit out_forward    = P0^5;
  19          sbit out_backward = P0^6;//电机控制输出 
  20          sbit limit_forward  = P1^3;
  21          sbit limit_backward = P1^4;//前进后退限位开关 
  22          sbit led_forward    = P1^6;
  23          sbit led_backward = P1^5;//前进后退限位指示灯 
  24          sbit light    = P3^7;//光线传感器 
  25          sbit change   = P1^0;//手动自动切换按键（默认自动）  
  26          sbit led_zhishi = P1^7;
  27          sbit beep = P0^0;  //定义蜂鸣器的引脚
  28          
  29          sbit W1=P2^2;
  30          sbit W2=P2^1;
  31          //定义DHT11数据口
  32          sbit DATA = P0^7;
  33          uc U8FLAG,U8temp,U8comdata,U8RH_data_H_temp,U8RH_data_L_temp,U8T_data_H_temp,U8T_data_L_temp,U8checkdata_t
             -emp,string[]={""};
  34          uc U8RH_data_H,U8RH_data_L,U8T_data_H,U8T_data_L,U8checkdata,DataGet;
  35          ui Mode,i = 0;
  36          bit bdata FlagStartRH,hot,cold,humid,dry;
  37          
  38          bit bdata flag1,flag2,change_flag,flag_shan,flag_shan1,flag_shan2,flag_HH;
  39          uc m,n,shan;
  40          
  41          
  42          //定时器0初始化
  43          void Timer0_Init()
  44          {
  45   1        ET0 = 1;        //允许定时器0中断
  46   1        TMOD = 0x21;       //定时器工作方式选择
  47   1        TL0 = 0xb0;     
  48   1        TH0 = 0x3c;     //定时器赋予初值
  49   1        TR0 = 1;        //启动定时器
  50   1        EA=1;
  51   1      }
  52          
  53          
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 2   

  54          void Init()
  55          {
  56   1        //定时器1初始化
  57   1        TMOD=0x21;//M1:M0=10 定时器0工作方式2, 可重置8位
  58   1        
  59   1        IT1=0;//低电平
  60   1        ET1=0;//中断允许
  61   1        TR1=1;//开启定时器计数
  62   1        
  63   1        TH1=0xfd;
  64   1        TL1=0xfd;//设置定时器初值
  65   1      //  TH1=0xFF;
  66   1      //  TL1=0xE8;
  67   1        PCON=0x00;//SCON=0
  68   1        
  69   1        //串口初始化
  70   1        SM0=0;
  71   1        SM1=1;//串口工作方式1 8位UART
  72   1        REN=1;//使能串行接收
  73   1        ES=1;//串口中断允许
  74   1        EA=1;//开启总中断允许位
  75   1      
  76   1      }
  77          void SendData(int humidity)
  78          {
  79   1        int i=0;
  80   1        unsigned char gewei,shiwei,array1[]={"HUMIDITY:  "};
  81   1        gewei=humidity%10+'0';
  82   1        shiwei=humidity/10+'0';
  83   1        array1[9]=shiwei;
  84   1        array1[10]=gewei;
  85   1      
  86   1        while(array1[i] != '\0')
  87   1        { 
  88   2          SBUF=array1[i];
  89   2          while(!TI);//若没有发送完数据 等待
  90   2          TI=0;//若发送完 标志位清0
  91   2          i++;
  92   2        }
  93   1      
  94   1      }
  95          void SendData2(int humidity)
  96          {
  97   1        int i=0;
  98   1        unsigned char gewei,shiwei,array1[]={" "};
  99   1        gewei=humidity%10+'0';
 100   1        shiwei=humidity/10+'0';
 101   1        array1[0]=shiwei;
 102   1        array1[1]=gewei;
 103   1      
 104   1        while(array1[i] != '\0')
 105   1        { 
 106   2          SBUF=array1[i];
 107   2          while(!TI);//若没有发送完数据 等待
 108   2          TI=0;//若发送完 标志位清0
 109   2          i++;
 110   2        }
 111   1      
 112   1      }
 113          
 114          void Delay1(ui j)
 115          {
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 3   

 116   1          uc i;
 117   1          for(;j>0;j--)
 118   1          {   
 119   2          for(i=0;i<27;i++);
 120   2          }
 121   1      } 
 122          
 123          void  Delay_10us(void)
 124          {
 125   1          uc i;
 126   1          i--;
 127   1          i--;
 128   1          i--;
 129   1          i--;
 130   1          i--;
 131   1          i--;
 132   1      } 
 133          
 134          
 135          
 136          /******************************************************************************
 137           * @ 函数名  ： Delay_10us
 138           * @ 功  能  ： 10us粗略延时
 139           * @ 参  数  ： 延时时间--单位10us
 140           * @ 返回值  ： 无
 141           ******************************************************************************/
 142          void Delay_10us_1(unsigned int time)
 143          {
 144   1        while(time--);
 145   1      }
 146           
 147           /******************************************************************************
 148           * @ 函数名  ： Simulate_Pwm
 149           * @ 功  能  ： 模拟PWM控制（需要不停运行）
 150           * @ 参  数  ： period 周期（单位10us）
 151           *              duty   占空比（低电平，0-100）
 152           * @ 返回值  ： 无
 153           ******************************************************************************/
 154          void Simulate_Pwm(unsigned char period, unsigned char duty)
 155          {
 156   1        int i;
 157   1        unsigned char low = period / 100 * duty; //低电平延时时间
 158   1        unsigned char high = period - low;       //高电平延时时间
 159   1        for(i=0;i<=500;i++)
 160   1        {
 161   2        beep = 0;        //蜂鸣器IO电平置低
 162   2        Delay_10us_1(low); //低电平延时时间
 163   2        beep = 1;        //蜂鸣器IO电平置高
 164   2        Delay_10us_1(high);//高电平延时时间
 165   2        }
 166   1      }
 167          
 168          /******************************************************************************
 169           * @ 函数名  ： main
 170           * @ 功  能  ： 主函数
 171           * @ 参  数  ： 无
 172           * @ 返回值  ： 无
 173           ******************************************************************************/
 174          
 175          void buzz(ui number)
 176          {
 177   1        if (number==1)
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 4   

 178   1        {
 179   2            Simulate_Pwm(100, 99);  //周期100*10us，占空比50%――频率：1KHz
 180   2            beep=0;
 181   2        }
 182   1        else
 183   1        {
 184   2          beep=0;
 185   2        }
 186   1      }
 187          
 188          void  COM(void)
 189          {
 190   1          uc i;
 191   1          for(i=0;i<8;i++)     
 192   1          {
 193   2              U8FLAG=2;
 194   2            while((!DATA)&&U8FLAG++);
 195   2          Delay_10us();
 196   2          Delay_10us();
 197   2          Delay_10us();
 198   2            U8temp=0;
 199   2              if(DATA)U8temp=1;
 200   2              U8FLAG=2;
 201   2          while((DATA)&&U8FLAG++);
 202   2            //超时则跳出for循环     
 203   2            if(U8FLAG==1)break;
 204   2            //判断数据位是0还是1   
 205   2               
 206   2          // 如果高电平高过预定0高电平值则数据位为 1 
 207   2             
 208   2          U8comdata<<=1;
 209   2            U8comdata|=U8temp;        //0
 210   2          }//rof
 211   1      }
 212          
 213          /*--------------------------------
 214          -----温湿度读取子程序 ------------
 215          --------------------------------
 216          ----以下变量均为全局变量--------
 217          ----温度高8位== U8T_data_H------
 218          ----温度低8位== U8T_data_L------
 219          ----湿度高8位== U8RH_data_H-----
 220          ----湿度低8位== U8RH_data_L-----
 221          ----校验 8位 == U8checkdata-----
 222          ----调用相关子程序如下----------
 223          ---- Delay();, Delay_10us();,COM(); 
 224          --------------------------------*/
 225          uc RH(void)
 226          {
 227   1          //主机拉低18ms 
 228   1          DATA=0;
 229   1        Delay1(180);  //原来为5
 230   1        DATA=1;
 231   1        //总线由上拉电阻拉高 主机延时20us
 232   1        Delay_10us();
 233   1        Delay_10us();
 234   1        Delay_10us();
 235   1        Delay_10us();
 236   1        //主机设为输入 判断从机响应信号 
 237   1        DATA=1;
 238   1        //判断从机是否有低电平响应信号 如不响应则跳出，响应则向下运行   
 239   1        if(!DATA)    //T !    
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 5   

 240   1        {
 241   2            U8FLAG=2;
 242   2            //判断从机是否发出 80us 的低电平响应信号是否结束   
 243   2            while((!DATA)&&U8FLAG++);
 244   2            U8FLAG=2;
 245   2            //判断从机是否发出 80us 的高电平，如发出则进入数据接收状态
 246   2            while((DATA)&&U8FLAG++);
 247   2            //数据接收状态     
 248   2            COM();
 249   2            U8RH_data_H_temp=U8comdata;
 250   2            COM();
 251   2            U8RH_data_L_temp=U8comdata;
 252   2            COM();
 253   2            U8T_data_H_temp=U8comdata;
 254   2            COM();
 255   2            U8T_data_L_temp=U8comdata;
 256   2            COM();
 257   2            U8checkdata_temp=U8comdata;
 258   2            DATA=1;
 259   2            //数据校验 
 260   2            U8temp=(U8T_data_H_temp+U8T_data_L_temp+U8RH_data_H_temp+U8RH_data_L_temp);
 261   2            if(U8temp==U8checkdata_temp)
 262   2            {
 263   3               U8RH_data_H=U8RH_data_H_temp;
 264   3               U8RH_data_L=U8RH_data_L_temp;
 265   3               U8T_data_H=U8T_data_H_temp;
 266   3               U8T_data_L=U8T_data_L_temp;
 267   3               U8checkdata=U8checkdata_temp;
 268   3            }
 269   2          return 1;
 270   2        }
 271   1        else   //传感器不响应
 272   1        {
 273   2           return 0;
 274   2        }
 275   1      }
 276          
 277          
 278          
 279          void delay5ms()   //误差 -0.000000000001us
 280          {
 281   1          unsigned char a,b;
 282   1          for(b=15;b>0;b--)
 283   1              for(a=152;a>0;a--);
 284   1      }
 285          
 286          
 287          /******LCD1602写命令函数********/
 288          void write_com(unsigned char command)
 289          {
 290   1        RS = 0; 
 291   1        RW = 0;   //高读低写
 292   1        E=0;
 293   1        LCD = command;
 294   1        delay5ms(); //这里延时最低要30纳秒 我们直接给5ms
 295   1        E = 1;    //使能拉高 
 296   1        delay5ms(); //最低要求延迟150纳秒 我们直接给5ms
 297   1        E = 0;
 298   1      }
 299          
 300          /******LCD1602写数据函数********/
 301          void write_data(unsigned char dat)
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 6   

 302          {
 303   1        RS = 1;
 304   1        RW = 0;
 305   1        E=0;
 306   1        LCD = dat;
 307   1        delay5ms(); //这里延时最低要30纳秒 我们直接给5ms
 308   1        E = 1;    //使能拉高 
 309   1        delay5ms(); //最低要求延迟150纳秒 我们直接给5ms
 310   1        E = 0;
 311   1      }
 312          /******初始化LCD1602********/
 313          void init_lcd1()
 314          { 
 315   1        write_com(0x06); //写入数据后光标自动右移 整屏不移动。
 316   1        write_com(0x0c); //开显示功能 无光标 不闪烁
 317   1        write_com(0x38); //数据总线8位 16X2显示 5*7点阵
 318   1        write_com(0x01); //清屏 0000 0001
 319   1        write_com(0x81); //在1602第一行第1个开始显示
 320   1      }
 321          
 322          
 323          void display(void)
 324            {uc array1[]={"HUMIDITY:      000000000000000000000000 MODE:"};
 325   1        while(array1[i] != '\0')
 326   1        { 
 327   2          write_data(array1[i]);
 328   2          i++;
 329   2        } 
 330   1      }
 331          
 332          void delay(ui x)//延时函数 
 333          {
 334   1        ui i,j;
 335   1        for(i=0;i<x;i++)
 336   1        for(j=0;j<110;j++);
 337   1      }
 338          
 339          int work(int s)//工作函数 
 340          {
 341   1         int w1=2;
 342   1         int w2=3;
 343   1        if(change==0)//判断切换是否按下 
 344   1        {
 345   2          buzz(0);
 346   2          delay(20);//////////////////////
 347   2          if(change==0)
 348   2          change_flag=~change_flag;//手动，自动切换 
 349   2          
 350   2          led_zhishi=change_flag;
 351   2          if(change_flag==1)
 352   2          {
 353   3            out_forward=1;
 354   3            out_backward=1;
 355   3            led_forward=1;
 356   3            led_backward=1;
 357   3          }
 358   2          buzz(1);
 359   2          while(!change)//释放 
 360   2          {buzz(1);}
 361   2        }
 362   1        
 363   1        if(change_flag==0)//自动模式 
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 7   

 364   1        { 
 365   2          write_com(0xC6);
 366   2          write_data('A');
 367   2          delay5ms();
 368   2          if(~light==0||flag_HH==1)//夜间（无光）时拉回衣架     flag_HH==1湿度高
 369   2          {
 370   3            delay(20);
 371   3            if(~light==0||flag_HH==1)
 372   3            {  if(s%w1 != 0)
 373   4              { out_forward=1;
 374   5                out_backward=1;
 375   5                delay(2500);}
 376   4              else if((limit_backward==0)&&(flag_shan==0))
 377   4              { 
 378   5                out_forward=1;
 379   5                out_backward=1;
 380   5                led_forward=0;
 381   5                
 382   5                for(shan=0;shan<6;shan++)
 383   5                {
 384   6                  led_backward=~led_backward;
 385   6                  buzz(led_backward);
 386   6                  delay(500);
 387   6                }
 388   5                flag_shan=1;
 389   5              }
 390   4              else if(limit_backward==1)
 391   4              { write_com(0xCD);
 392   5                write_data('I');
 393   5                write_data('N');
 394   5                write_data(' ');
 395   5                out_forward=0;
 396   5                out_backward=1;///
 397   5                
 398   5                led_backward=1;
 399   5                led_forward=0;
 400   5                flag_shan=0;
 401   5              }
 402   4            }
 403   3            s=w1;
 404   3          }
 405   2          else if(~light==1&&flag_HH==0)//白天（有光）时伸出衣架 
 406   2          {
 407   3            delay(20);
 408   3            if(~light==1&&flag_HH==0)
 409   3            { if(s%w2 != 0)
 410   4              { 
 411   5                out_forward=1;
 412   5                out_backward=1;
 413   5                delay(2500);}
 414   4              else if((limit_forward==0)&&(flag_shan==0))
 415   4              { 
 416   5                out_forward=1;
 417   5                out_backward=1;
 418   5                
 419   5                led_backward=0;
 420   5                for(shan=0;shan<6;shan++)
 421   5                {
 422   6                  led_forward=~led_forward;
 423   6                  buzz(led_forward);
 424   6                  delay(500);
 425   6                }
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 8   

 426   5                flag_shan=1;
 427   5              }
 428   4              else if(limit_forward==1)
 429   4              { write_com(0xCD);
 430   5                write_data('O');
 431   5                write_data('U');
 432   5                write_data('T');
 433   5                out_forward=1;////
 434   5                out_backward=0;
 435   5                
 436   5                led_backward=0;
 437   5                led_forward=1;
 438   5                flag_shan=0;
 439   5              }
 440   4            s=w2;
 441   4            }
 442   3          }
 443   2        }
 444   1        else if(change_flag==1)//手动模式 
 445   1        { 
 446   2          write_com(0xC6);
 447   2          write_data('M');
 448   2          if((in_forward==0)&&(limit_forward==1))//关闭是否按下 
 449   2          {
 450   3            buzz(0);
 451   3            delay(5);
 452   3            if((in_forward==0)&&(limit_forward==1))
 453   3            { write_com(0xCD);
 454   4                write_data('O');
 455   4                write_data('U');
 456   4                write_data('T');
 457   4              buzz(1);
 458   4              out_forward=1;
 459   4              out_backward=~out_backward;//按一下伸出，再按一下，停止 
 460   4              
 461   4              buzz(1);
 462   4              led_forward=1;
 463   4              led_backward=out_backward;
 464   4              flag_shan1=0;
 465   4              
 466   4            }
 467   3            while(!in_forward)//释放
 468   3            buzz(1);
 469   3          }
 470   2          else if((in_backward==0)&&(limit_backward==1))//打开是否按下 
 471   2          {
 472   3            buzz(0);
 473   3            delay(5);
 474   3            if((in_backward==0)&&(limit_backward==1))
 475   3            { write_com(0xCD);
 476   4              write_data('I');
 477   4              write_data('N');
 478   4              write_data(' ');
 479   4              buzz(1);  
 480   4              out_backward=1;
 481   4              out_forward=~out_forward;//按一下收回，再按一下，停止  
 482   4              
 483   4              buzz(1);
 484   4              led_backward=1;
 485   4              led_forward=out_forward;
 486   4              flag_shan2=0;
 487   4              
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 9   

 488   4            }
 489   3            while(!in_backward)//按键释放
 490   3            buzz(1);
 491   3          }
 492   2          if((limit_forward==0)&&(flag_shan1==0))
 493   2          {
 494   3            delay(5);
 495   3            if((limit_forward==0)&&(flag_shan1==0))
 496   3            { 
 497   4              
 498   4              out_backward=1;
 499   4              led_backward=0;
 500   4              for(shan=0;shan<6;shan++)
 501   4              {
 502   5                led_forward=~led_forward;
 503   5                buzz(led_forward);
 504   5                delay(500);
 505   5              }
 506   4              flag_shan1=1;
 507   4            }
 508   3          }
 509   2          if((limit_backward==0)&&(flag_shan2==0))
 510   2          {
 511   3            delay(5);
 512   3            if((limit_backward==0)&&(flag_shan2==0))
 513   3            { 
 514   4              
 515   4              out_forward=1;
 516   4              led_forward=0;
 517   4              for(shan=0;shan<6;shan++)
 518   4              {
 519   5                led_backward=~led_backward;
 520   5                buzz(led_backward);
 521   5                delay(500);
 522   5              }
 523   4              flag_shan2=1;
 524   4            }
 525   3          }
 526   2        }
 527   1      return s;
 528   1      }
 529          
 530          void main()//主函数 
 531          {
 532   1        uc testnum,shiwei,gewei;
 533   1        ui humidity;
 534   1        int s=6;//避免电机突然反向电压不稳的保护措施，每个方向对应一种状态，检测到状态改变先让电机停止转动再反向
 535   1        int i;
 536   1        buzz(1);
 537   1        led_zhishi=0;
 538   1        Timer0_Init();
 539   1        //Init();
 540   1        init_lcd1();
 541   1        testnum = RH();
 542   1        FlagStartRH = 0;
 543   1        humidity = U8RH_data_H;  //读出湿度，只取整数部分
 544   1        display();
 545   1        SendData(humidity);
 546   1        i=1;
 547   1        while(1)//进入死循环
 548   1        {  
 549   2          s=work(s);//调用工作函数 
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 10  

 550   2          if (FlagStartRH == 1)  //温湿度转换标志检查
 551   2          {
 552   3            write_com(0x8A);
 553   3            testnum = RH();
 554   3            FlagStartRH = 0;
 555   3            humidity = U8RH_data_H;  //读出湿度，只取整数部分
 556   3            gewei=humidity%10+'0';
 557   3            shiwei=humidity/10+'0';
 558   3            write_data(shiwei);
 559   3            write_com(0x8B);
 560   3            write_data(gewei);
 561   3            delay5ms();
 562   3            if(humidity>=80)
 563   3            flag_HH=1;
 564   3            else 
 565   3            flag_HH=0;
 566   3            TR0 = 1;
 567   3          }
 568   2        }
 569   1      }
 570          
 571          //定时器0中断
 572          void Timer0_ISR (void) interrupt 1 using 0
 573          {
 574   1        ui RHCounter;
 575   1        TL0 = 0xb0;
 576   1        TH0 = 0x3c;     //定时器赋予初值
 577   1      
 578   1        //每5秒钟启动一次温湿度转换
 579   1          RHCounter ++;
 580   1          if (RHCounter >= 20)
 581   1          {
 582   2             FlagStartRH = 1;
 583   2           RHCounter = 0;
 584   2           TR0=0;
 585   2          }
 586   1      }
 587          void SeriesInterrupt() interrupt 4
 588          {
 589   1        if(RI)//接收完毕 接收中断位RI置1
 590   1        {
 591   2          
 592   2          DataGet=SBUF;//取出接收的数据
 593   2          RI=0;
 594   2          DataGet=DataGet-'0';
 595   2          SendData2(DataGet);//将接收的数据发送出去
 596   2      //    if(DataGet=='Y')
 597   2      //      P1=0x00;//开灯
 598   2      //    else if(DataGet=='N')
 599   2      //      P1=0xFF;//关灯
 600   2      //    else
 601   2      //      P1=0x55;//交替
 602   2        }
 603   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1572    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      84
C51 COMPILER V9.59.0.0   BEST                                                              06/09/2022 23:10:24 PAGE 11  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
